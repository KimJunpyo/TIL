# 코드스테이츠 63일차 정리(Tree, Binary Search Tree, Graph)

생성일: 2023년 5월 11일 오전 9:27
태그: 코드스테이츠 일일 정리

# Tree

> 단방향 그래프의 한 구조로, 나무의 형태를 닮은 계층적 자료구조
> 
- 하나의 데이터에 여러 개의 데이터가 있을 수 있는 비선형 구조를 가지고 있다.
- 트리는 사이클이 없다.
사이클: 어떤 한 노드에서 출발해 다른 노드들을 거쳐 출발했던 노드로 돌아올 수 있게 간선이 연결되어 있는 것
- 즉, 사이클이 없는 비선형 연결 그래프이다.

## Tree 구조의 용어

1. Root: 트리 구조의 가장 최 상단에 위치한 꼭짓점 데이터
2. Node: 트리 구조의 데이터
3. Edge(간선): 각 Node를 상하 계층으로 연결하는 관계선
4. 부모 / 자식 노드: 간선으로 연결되어 상하 계층이 구분된 노드들
상단에 위치한 노드를 부모 노드, 하단에 위치한 노드를 자식 노드라고 부른다.
5. 리프 노드(Leaf): 자식이 없는 마지막 노드, 나뭇잎처럼 트리의 끝을 의미한다.
6. 깊이(depth): Root를 기준으로 특정 노드까지의 길이
7. Level: 같은 깊이를 가지고 있는 노드를 묶는 단위
8. 높이: 리프 노드를 기준으로 Root 까지의 길이
9. 형제 노드: 같은 Level에 나란히 있는 노드
10. 서브 트리: 트리의 내부에 또 다른 트리의 구조를 가지고 있는 작은 트리

## Tree의 실사용 예제

- 컴퓨터의 파일 탐색기(디렉토리 구조)가 대표적인 Tree 구조이다.
    - 컴퓨터는 C 드라이브를 기준으로 계속 하위 트리로 또 다른 서브 트리인 폴더를 구성하여 계속 아래로 뻗어가는 구조를 가지고 있다.

### Tree JavaScript 코드

```jsx
class Tree {
  constructor(value) {
    this.value = value;
    this.children = [];
  }

  insertNode(value) {
    const childNode = new Tree(value);
    this.children.push(childNode);
  }

  contains(value) {
    console.log(this, value);
    if (this.value === value) {
      return true;
    }
    for(let i = 0; i < this.children.length; i++){
      if(this.children[i].contains(value)){
        return true;
      }
    }
    return false;
  }
}
```

# Binary Tree

> 자식 노드가 최대 두 개인 노드로 구성된 트리
> 
- 두 개의 노드를 left, right 노드로 관리하게 된다.
- 이진 트리는 정 이진 트리, 포화 이진 트리, 완전 이진 트리로 구분된다.

![](https://velog.velcdn.com/images/player1552/post/a40b4de8-123a-493e-b25e-e76272d68c86/image.PNG)


## Binary Tree 종류

1. 정 이진 트리(Full Binary Tree): 각 노드가 0개 혹은 2개의 자식 노드를 갖는 이진 트리
2. 포화 이진 트리(Perfect Binary Tree): 정 이진 트리면서 완전 이진 트리인 경우.
모든 레벨이 가득 채워져 있는 트리
3. 완전 이진 트리(Complete Binary Tree): 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 왼쪽은 채워져 있는 트리

# Binary Search Tree

> 이진 탐색 알고리즘을 적용한 이진 트리
> 
- 이진 탐색: 정렬된 데이터 중에서 특정한 값을 찾기 위한 탐색 알고리즘
- 이진 탐색 트리는 Root를 이진 탐색 알고리즘의 Mid로 사용한다.
- 따라서, **Root 기준 왼쪽 서브 트리는 모두 Root보다 작으며, 오른쪽 서브 트리는 Root 보다 크다**

## 이진 탐색 트리의 탐색 과정

1. 루트 노드의 키와 탐색하고자 하는 값을 비교하고 찾고자 하는 값이라면 탐색 종료
2. 루트 노드보다 작다면, 왼쪽 서브 트리로 이동 후 다시 탐색 시작
3. 루트 노드보다 크다면, 오른쪽 서브 트리로 이동 후 다시 탐색 시작
4. 1~3의 과정을 반복하여 리프 노드에 이르렀을 때에도 원하는 값이 없다면 탐색 종료
- 위의 과정을 통해 탐색하게 되면 아무리 오래 걸려도 트리의 높이만큼만 걸리게 된다.

# 트리 순회(Tree Traversal)

> 트리 순회는 특정 목적에 의해 트리의 모든 노드를 한 번씩 방문하는 것을 의미한다.
> 
- 아래의 예시 트리를 이용하여 각 순회별로 어떤 결과가 나오는지 보고 더 쉽게 이해할 수 있다.

![](https://velog.velcdn.com/images/player1552/post/1db4b69f-4c5c-43bb-8645-8e921ad380c2/image.png)

## 전위 순회(preorder Traverse)

> 루트에서 시작하여 각 노드의 왼쪽 자식 노드들을 순차적으로 탐색한 뒤, 오른쪽 자식 노드들을 탐색하기 시작하는 순회 방법
> 
- 결과값: 4, 2, 1, 3, 6, 5, 7

## 중위 순회(inorder traverse)

> 가장 왼쪽 리프 노드부터 시작하여 각 서브 트리의 루트를 기준으로 왼쪽-루트-오른쪽의 방식으로 탐색하는 순회 방법
> 
- 결과값: 1, 2, 3, 4, 5, 6, 7
- 이진 탐색 트리의 노드들을 오름차순으로 탐색하고 싶을 때 위의 방법을 사용하면 된다.

## 후위 순회(postorder traverse)

> 루트를 가장 마지막에 순회하며, 가장 왼쪽 리프 노드부터 시작하여 모든 자식 노드를 탐색한 후, 루트 노드를 탐색하는 순회 방법
> 
- 결과값: 1, 3, 2, 5, 7, 6, 4
- 자식 노드를 모두 탐색하고 루트 노드에 오기 때문에 특정 서브 노드 전체를 삭제하거나, 자식 노드들을 삭제하는 등의 방법이 필요할 때 자주 사용된다.

## 레벨 순회(levelorder traverse)

> 트리의 레벨을 기준으로 하여 같은 레벨에 있는 노드는 왼쪽-오른쪽의 진행 방향으로 탐색하는 순회 방법
> 
- 결과값: 4, 2, 6, 1, 3, 5, 7

# Graph

> 정점과 간선으로 이루어져 있고, 각 정점들이 서로 연결되어 있는 관계를 표현한 자료구조
> 

## Graph 용어

1. 인접 정점: 하나의 정점에서 간선에 의해 직접 연결된 정점
2. 가중치 그래프: 각 간선에 어떤 수치가 적용되어 있는 그래프
3. 비가중치 그래프: 각 간선에 수치가 없는 그래프
4. 진입차수(in-degree) / 진출차수(out-degree): 한 정점에 들어오고 나가는 간선이 몇개인지를 나타내는 용어
5. 자기 루프: 정점에서 진출한 간선이 바로 자기 자신과 연결되어 있는 것
6. 사이클: 어떤 한 정점에서 출발하여 다시 해당 정점으로 돌아올 수 있는 것

## 인접 행렬과 인접 리스트

### 인접 행렬

> 각 정점의 연결 관계를 2차원 배열의 형태로 구현하는 방법
> 
- 2차원 배열에서는 1차원 인덱스와 2차원 인덱스가 서로 연결되어 있을 때 1, 혹은 가중치를 가지고 연결되지 않았을때엔 0을 가진다.

### 인접 리스트

> 각 정점의 연결 관계를 리스트 형태로 구현하는 방법
> 
- 각 정점을 리스트로 만든 뒤, 어떤 정점 A와 연결된 정점 C가 있고, 정점 C와 연결된 다른 정점이 없을 때엔 A 리스트에 C가 요소로 들어가고, C 리스트에는 Null 요소가 들어가게 된다.

### 인접 행렬 VS 인접 리스트

> 인접 행렬
1. 두 정점 사이의 관계를 파악하기 수월함
⇒ A와 B의 정점 관계를 파악하고 싶을 때, 단순하게 [A][B]의 값을 확인하면 되기 때문이다.
2. 가장 빠른 경로를 찾고자 할 때 주로 사용됨
⇒ 인접 행렬의 경우 인덱스를 직접 접근하여 조회가 이뤄지기 때문에 O(1)의 시간으로 동작한다. 그러나, 인접 리스트의 경우 노드의 수만큼 직접 리스트를 타고 들어가며 조회하기 때문에 O(N)의 시간이 소요되며 이는 빠른 경로를 찾을 때에도 시간적 손실이 있게 된다.

인접 리스트
1. 메모리의 효율을 중요시 할 때 사용됨
⇒ 인접 행렬은 연결이 가능한 모든 경우의 수를 저장하기 때문에 메모리의 소모가 심하지만, 인접 리스트는 각 정점을 나타내는 리스트 하나만을 가지고 서로의 연결 관계를 표현하므로 효율성이 좋다.
> 

## BFS(Breadth-First Search)

> 최단 경로를 탐색하는 알고리즘
> 
- 너비 우선 탐색이라고도 부르며, 어떤 한 정점을 기준으로 가까이에 있는 정점들을 우선 탐색하면서 원하는 정점을 찾는 알고리즘이다.
- 최단 경로를 사용할 때 사용되는 이유는 알고리즘 자체가 가까이 있는 정점들을 기준으로 탐색하기 때문에 원하는 값이 찾아졌다면 그 경로가 자동적으로 최단거리가 되기 때문이다.

## DFS(Depth First Search)

> 하나의 경로를 끝까지 탐색하는 알고리즘
> 
- 한 정점에서 시작하여 하나의 경로 끝까지 탐색을 진행하고, 원하는 값이 없다면 옆의 경로를 끝까지 탐색하면서 모든 정점을 확인하는 알고리즘이다.
- BFS보다는 시간적으로 더 오래 걸릴 수 있으나, 모든 노드를 탐색하는 경우 및 원하는 값까지의 경로를 표현할 때에 자주 사용된다.

## 처음 듣거나 어려웠던 부분(암기할 부분)

이외의 순회 방법이 있는지 검색해보기